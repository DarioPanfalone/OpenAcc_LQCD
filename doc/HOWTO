/////////////////////////////////////////////////////////////
// This is a brief guide to this code, valid around commit //
// e1ef9998912a8921637f2cb7d7889e478de56ebd.               //
// This guide was updated after                            //
// fa60fb52b1ac9f8356b7529aa00cd54dca57fabb.               //
/////////////////////////////////////////////////////////////
********
*BASICS*
********

1 WHAT'S WHAT

+ src: the code.
+ tools: various utilities, for example to generate the rational
  approximations and test them (at present the only thing, but this
  folder could contain tools to convert configurations from a format to
  another and things like that),
+ scripts: basically, collections of commands that you would kave to
  type too many times.
+ saved_approxs: saved rational approximations, for your convenience.
+ build: the place where build happens. 
+ build/run: the place where your program should run. Try to put here
  all the things your program needs (rational approximation files,
  start configurations, files where data should be appended and so on.)
+ docs: where documentation should be.

2 THINGS YOU MAY WANT TO DO

+ 2.1 Run a simulation
 +2.1.1 Parameters or things you may want to modify
  The first thing you may want to touch is the file 
  src/OpenAcc/main.c. 
  The parameters of the simulations are now written directly in the
  code. Some could theoretically be read from file, some others are
  far better to be known at compile time. Examples:
  - The starting mode: from a saved gauge configuration or from
    scratch? See src/OpenAcc/main.c.
  - Lattice dimensions and block dimensions: these are #defines and it 
    is far better to write them in the code directly. The lattice
    dimensions are called nx,ny,nz,nt ('grep' is your friend to find
    them, since their position could vary in next development
    iterations of the code), block dimensions are DIM_BLOCK_X,
    DIM_BLOCK_Y,DIM_BLOCK_Z (now they don't, but in the future they
    might depend on the specific kernel).

  - fermion parameters:
    They can be read from an input file. Their initialization is
    performed in 
     src/Include/fermion_parameters.c: void init_ferm_params()
  - HMC parameters: initialization performed in 
     src/OpenAcc/md_integrator.c: 
           void initialize_md_global_variables()
  - Inversion - multishift inversion parameters: now set in 
     src/OpenAcc/main.c
  - Background field: if active (#ifdef BACKFIELD) see
     src/OpenAcc/backfield.c: void set_field_quanta()
     src/OpenAcc/backfield.c: void init_backfield() 
        // calculation of the real background phases
  - random number generation: see 
     src/Rand/random.c: void initrand()


 +2.1.2 I just want to compile and run it!
  To compile it, go in the build directory. There, if you already have
  a makefile and all the things you need, use: 

   make main
   cd run
   ./main <your carefully crafted input file>

  Otherwise...
  2.1.2.1 COMPILATION
  But if you don't have a makefile, or if you changed the dependence
  structure in your code, you have to create a makefile first. NO
  FEAR! The generate_makefile.py utility will do it for you.

  The generate_makefile.py takes a number of arguments, namely 
 
  - a list of files containing a main() function
  - a compiler&linker flag option.
  
  For example:

  [OPENACCREPO/build]~>./generate_makefile.py
  Please specify one compiler: either PGISLOW, GNU or PGI
 
  As you see, it will tell you to choose a compiler. Try, for example


  [OPENACCREPO/build]~>./generate_makefile.py GNU ../src/OpenAcc/main.c \
                      ../src/DbgTools/deo_doe_test.c > makefile

  and a makefile will be generaqted, using gcc and -O3 optimization
  (for more informations, look into generate_makefile.py). 

  Then just  type
  
  make main

  NOTICE:
  You may need to do this on the right machine, with the right modules.
  For example, on the Pisa localui3, if you use the PGI compiler,
  you have to execute

  ../scripts/vai_su_cudawn?.sh    # choose 6 or 7
  module load pgi                 # last version
  module load cuda                # last version
  export PGI_ACC_BUFFERSIZE= ???? #think
  
  where ???? stands of a reasonable number (for a 32^3x8 I use
  3000000000, do your calculations for the lattice you intend to use).
  A small buffer will make your program fail but a too big one will
  make your program need too much memory, up to the point where... it
  will fail.

 
  FAQ
  Q: Why don't you just use autotools?
  A: Because I don't know how to use them! If you can do better, do
     it (please).

  2.1.2.2 RUN
  Go into ./run and launch ./main <input_file>. Here, the program will
  need some  files that you have to prepare in advance. Another section
  of this  guide will tell you what you usually need to prepare, of
  course if  you look into the initialization function listed above in
  section 2.1.1.
  
  Launching "./main" without an input file won't be that useful,
  except for the fact that an "input_template" will be generated.
  In this repo is also included a "input_openacc" file that serves as
  a better template.
  You will also need to generate the "rational approximations". If the
  program does not find them, it will tell you exactly what is needed, 
  and generate a "genappfiles.sh" file which contains all the command
  you need to run to generate them. BEWARE: some lines will be
  duplicated, e.g. the ones regarding up and down flavours (if they
  have the same mass).


3 FILES YOU MAY NEED TO RUN THE PROGRAM
  The kind of file needed are usually the rational approximations and
  the starting gauge configuration file (unless you want to start from
  a random configuration).

+3.0 Input file
  The format of the input file is pretty self explanatory. If you try
  to run "./main" without arguments, it will produce a template, but
  you can also look to "/buld/run/input_openacc" to take inspiration.
 +3.0.1 Verbosity level
  Don't forget to set the VerbosityLv variable to the desired result. 
  The value of it is assigned to the 'verbosity_lv' global variable.
  As a rule of thumb, '5' prints all, '1' prints nearly nothing. Note
  that the behaviour of VerbosityLv is likely to change over time, no
  policy is yet decided.

  
  REMARKS:
  SEEMINGLY INSIGNIFICANT THINGS THAT YOU HAVE TO TAKE CARE OF:
  A parameter named "ExpMaxEigenvalue" is expected, and is an estimate
  of the maximum eigenvalue of the Dirac Operator. This will influence
  the choice of the rational approximations you need.
  Notice that the highest eigenvalue of the fermion matrix is
  calculated during the update and printed out if the right verbosity
  value is set.
  Notice that the smaller StoutSteps is, the larger this number. 

  
  What you CAN'T set with the input file (now) and you have to
  recompile*:
  - The type of gauge action. [triggers some long recompilation]
  - The stouting strength RHO 
  - The lattice dimensions in /src/OpenAcc/geometry.h [this will
    practically trigger a full recompilation].
  Other things that need recompilation
  - Switching on/off the ability to simulate external field
  - Switching on/off the ability to simulate imaginary chemical
    potentials
  - Changes in the input file format

  *it is not a problem if you use gcc or pgi to compile for cpus, but
   compiling with pgi for gpus can require time, depending on the
   version of the compiler.
 
+3.1 Rational Approximation files
  Rational approximations are used to approximate powers (like 1/4,
  1/8) of the Dirac Operator.
  You need 3 rational approximations files for each quark flavour in the
  theory, one for the first inversion (to map the original
  gaussianly generated pseudofermion to one generated according to the
  right pdf), one used during the molecular dynamics evolution (with a
  lower order, so less precise, for speed), and a third one for the
  calculation of the final action for the metropolis test (more
  precise). It is common though that at least 2 flavour are degenerate
  in mass, and this allows you to use the same set of rational
  approximations. For example, for a Nf=2+1 simulation, you need a total
  of 6 rational approximations.
  NOTICE: the name of the rational approximation file is related to
  its content, and can be generated using the function
  char* rational_approx_filename() in
  src/RationalApprox/rationalapprox.h.

 +3.1.1 How to generate and check rational approximations.
  Use the tools in tools/. A makefile should be there. 
  +'rgen' (rationalapprox_calc.c) 
   the tool for generating them, it takes the tolerance (plus other
   things) as input and will try to increase the number of poles until
   the required level of acuracy is reached. It takes time to generate
   high order approximations (~minutes). Notice that it needs arbitary
   precision libraries to be compiled.
  +'rgenfo' (rationalapprox_calc.c) 
   Same as rgen, but the order of the approximation is fixed.
  +'ratnormalizer' (normalize_ratapprox.c) 
   takes a rational approx and
   rescales it so that the upper limit of the validity range is 1.
  + 'eval_ratapprox' (eval_ratapprox.c)
   Are you sure that your rational approx works? With this tool, you
   can check! 'bc -l' is your friend too.
  
+3.2 Gauge configuration files
  For the format of the gauge configuration files, look in 
  src/OpenAcc/io.c: print_su3_soa() - read_su3_soa() or similar.
  The read and/or write of the initial/final gauge configuration file
  is usually done in /src/OpenAcc/main.c.

4 DEBUG TOOLS
  4.1 NORANDOM Mode
  If you need your run to be reproducible and want the rng not used,
  use '#define NORANDOM' in 

