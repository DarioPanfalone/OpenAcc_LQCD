/////////////////////////////////////////////////////////////
// This is a brief guide to this code, valid around commit //
// e1ef9998912a8921637f2cb7d7889e478de56ebd.               //
/////////////////////////////////////////////////////////////
********
*BASICS*
********

1 WHAT'S WHAT

+ src: the code.
+ tools: various utilities, for example to generate the rational
  approximations and test them (at present the only thing, but this
  folder could contain tools to convert configurations from a format to
  another and things like that),
+ scripts: basically, collections of commands that you would kave to
  type too many times.
+ saved_approxs: saved rational approximations, for your convenience.
+ build: the place where build happens. 
+ build/run: the place where your program should run. Try to put here
  all the things your program needs (rational approximation files,
  start configurations, files where data should be appended and so on.)
+ docs: where documentation should be.

2 THINGS YOU MAY WANT TO DO

+ 2.1 Run a simulation
 +2.1.1 Parameters or things you may want to modify
  The first thing you may want to touch is the file 
  src/OpenAcc/main.c. 
  The parameters of the simulations are now written directly in the
  code. Some could theoretically be read from file, some others are
  far better to be known at compile time. Examples:
  - Lattice dimensions and block dimensions: these are #defines and it 
    is far better to write them in the code directly.
  - fermion parameters:
    They can be read from an input file. Their initialization is
    performed in 
     src/Include/fermion_parameters.c: void init_ferm_params()
  - HMC parameters: initialization performed in 
     src/OpenAcc/md_integrator.c: 
           void initialize_md_global_variables()
  - Inversion - multishift inversion parameters: now set in 
     src/OpenAcc/main.c
  - Background field: if active (#ifdef BACKFIELD) see
     src/OpenAcc/backfield.c: void set_field_quanta()
     src/OpenAcc/backfield.c: void init_backfield() 
        // calculation of the real background phases
  - random number generation: see 
     src/Rand/random.c: void initrand()


 +2.1.2 I just want to compile and run it!
  To compile it, go in the build directory. There, if you already have
  a makefile and all the things you need, use: 

   make main
   cd run
   ./main

  Otherwise...
  2.1.2.1 COMPILATION
  But if you don't have a makefile, or if you changed the dependence
  structure in your code, you have to create a makefile first. NO
  FEAR! The generate_makefile.py utility will do it for you.
  First, you may want to modify generate_makefile.py so that the
  string compiler_linker_setting at line 16 is the one you want.

  COMMENT: this procedure could be streamlined and improved.

  After that, invoke
  
  ../scripts/generate_makefile.sh

  and a makefile will be generated. Then just type
  
  make main

  NOTICE:
  You may need to do this on the right machine, with the right modules.
  For example, on the Pisa localui3, you have to do

  ../scripts/vai_su_cudawn?.sh    # choose 6 or 7
  module load pgi                 # last version
  module load cuda                # last version
  export PGI_ACC_BUFFERSIZE= ???? #think
  
  where ???? stands of a reasonable number (for a 32^3x8 I use
  3000000000, do your calculations for the lattice you intend to use).
  A small buffer will make your program fail but a too big one will
  make your program need too much memory, up to the point where... it
  will fail.
  

  FAQ
  Q: Why don't you just use autotools?
  A: Because I don't know how to use them! If you can do better, do
     it (please).

  2.1.2.2 RUN
  Go into ./run and launch ./main. Here, the program will need some
  files that you have to prepare in advance. Another section of this
  guide will tell you what you usually need to prepare, of course if
  you look into the initialization function listed above in 
  section 2.1.1.
  
   

3 FILES YOU MAY NEED TO RUN THE PROGRAM
  The kind of file needed are usually the rational approximations and
  the starting gauge configuration file (unless you want to start from
  a random configuration).
+3.1 Rational Approximation files
  Rational approximations are used to approximate powers (like 1/4,
  1/8) of the Dirac Operator.
  You need 3 rational approximations files for each quark flavour in the
  theory, one for the first inversion (to map the original
  gaussianly generated pseudofermion to one generated according to the
  right pdf), one used during the molecular dynamics evolution (with a
lower order, so less precise, for speed), and a third one for the
calculation of the final action for the metropolis test (more
precise). It is common though that at least 2 flavour are degenerate
in mass, and this allows you to use the same set of rational
approximations. For example, for a Nf=2+1 simulation, you need a total
of 6 rational approximations.
  NOTICE: the name of the rational approximation file is related to
its content, and can be generated using the function
char* rational_approx_filename() in
src/RationalApprox/rationalapprox.h.

 +3.1.1 How to generate and check rational approximations.
  Use the tools in tools/. A makefile should be there. 
  +'rgen' (rationalapprox_calc.c) 
   the tool for generating them, it takes some arguments and also may
   need some time for high order approximations. Notice that it needs
   arbitary precision libraries to be compiled.
  +'ratnormalizer' (normalize_ratapprox.c) 
   takes a rational approx and
   rescales it so that the upper limit of the validity range is 1.
  + 'eval_ratapprox' (eval_ratapprox.c)
   Are you sure that your rational approx works? With this tool, you
   can check! 'bc -l' is your friend too.
  
+3.2 Gauge configuration files
  For the format of the gauge configuration files, look in 
  src/OpenAcc/io.c: print_su3_soa() - read_su3_soa() or similar.
  The read and/or write of the initial/final gauge configuration file
  is usually done in /src/OpenAcc/main.c.


