\documentclass[a4paper,10pt]{book}
%\documentclass[a4paper,10pt]{scrartcl}

\usepackage[utf8]{inputenc}

\newcommand{\cverb}{\linebreak[5]\verb}

\title{{\Huge \bf YALQCDSS Manual} \\
Yet Another Lattice QCD Simulation Suite \\
{\small Valid around commit 
fcd2e9c282f345b00835d1d5bf1a91ed5e357303}}
\author{M. Mesiti\\{\small University Of Pisa and INFN - Sezione di Pisa}}


\begin{document}
\maketitle
\date{}

\chapter{Basics}

 \section{Directory content}

  \begin{itemize}
   \item \texttt{src}: the code.
   \item tools: various utilities, for example to generate the rational
    approximations and test them (at present the only thing, but this
    folder could contain tools to convert configurations from a format to
    another and things like that), 
   \item scripts: basically, collections of commands that you would have to
    type too many times.
   \item \verb|saved_approxs|: saved rational approximations, for your 
convenience. 
   \item build: the place where build happens. 
   \item build/run: the place where your program should run. Try to put here
    all the things your program needs (rational approximation files,
    start configurations, files where data should be appended and so on.)
   \item docs: where documentation should be.
\end{itemize}


\section{Thing you may want to do}

\subsection{Run a simulation}
 
    

 \subsubsection{I just want to compile and run it!}
  To compile it, go in the build directory. There, if you already have
  a makefile and all the things you need, use: 

  \begin{verbatim}
   make main
   cd run
   ./main <your carefully crafted input file>
  \end{verbatim}
  Otherwise...

  
  \subsubsection{Compilation}
  But if you don't have a makefile, or if you changed the dependence
  structure in your code, you have to create a makefile first. NO FEAR! The 
  \verb|generate_makefile.py| utility will do it for you.

  The \verb|generate_makefile.py| takes a number of arguments (in any order), 
namely 
 \begin{itemize}
  \item a list of files containing a \verb|main()| function
  \item a \verb|compiler&linker| flag option.
 \end{itemize}

  
  For example:
  \begin{verbatim}
  [OPENACCREPO/build]~>./generate_makefile.py
  Please specify one compiler: either PGISLOW, GNU or PGI
 \end{verbatim}
  As you see, it will tell you to choose a compiler. Try, for example

  \begin{verbatim}
  [OPENACCREPO/build]~>./generate_makefile.py GNU ../src/OpenAcc/main.c \
                      ../src/DbgTools/deo_doe_test.c > makefile
 \end{verbatim}
  and a makefile will be generated, using gcc and -O3 optimization
  (for more informations, look into \verb|generate_makefile.py|). 

  Then just  type
  
  \begin{verbatim}
  make main
 \end{verbatim}
  {\bf NOTICE:}\\
  You may need to do this on the right machine, with the right modules.
  For example, on the Pisa localui3, if you use the PGI compiler,
  you have to execute
\begin{verbatim}
  ../scripts/vai_su_cudawn?.sh    # choose 6 or 7
  module load pgi                 # last version
  module load cuda                # last version
  export PGI_ACC_BUFFERSIZE= ???? #think
\end{verbatim}

  where $????$ stands of a reasonable number (for a $32^3\times8$ I use
  3000000000, do your calculations for the lattice you intend to use).
  A small buffer will make your program fail (\emph{possibly silently}) but a 
too big one will make your program need too much memory, up to the point 
where... it will fail.

 
  FAQ \\
  Q: Why don't you just use autotools? \\
  A: Because I don't know how to use them! If you can do better, do
     it (please).

  \subsubsection{Run}
  Go into \verb|./run| and launch \verb|./main <input_file>|. Here, the program 
  will  need some  files that you have to prepare in advance. Another section
  of this  guide will tell you what you usually need to prepare, of
  course if  you look into the initialization function listed above in
  section (\ref{initfunction}) you can understand anyway.
  
  Launching \verb|./main| without an input file won't be that useful,
  except for the fact that an \verb|input_template| will be generated.
  In this repo is also included a \verb|input_openacc| file that serves as
  a better template.
  You will also need to generate the \emph{rational approximations}. If the
  program does not find them, it will tell you exactly what is needed, 
  and append all the command
  you need to run to generate them to \verb|genappfiles.sh|. The best way make 
  use of it is to run
  \begin{verbatim}
   bash <(sort genappfiles.sh | uniq)
  \end{verbatim}
  as also suggested by the program. 

\section{Files you may need to run the program}
  The kind of file needed are usually the rational approximations and
  the starting gauge configuration file (unless you want to start from
  a random configuration).

 \subsection{Input file}
  The format of the input file is pretty self explanatory. If you try
  to run \verb|./main| without arguments, it will produce a template, but
  you can also look to \verb|/buld/run/input_openacc| and take inspiration from 
  it. Various remarks on its content:
 
 \begin{itemize}
  \item{Theory: \verb|ActionParameters|.}
  Here you can set the value of $\beta$ and the number of stout steps used. You 
have to write here also the value of $\rho$, but unfortunately at present 
\verb|RHO| is used in a lot of places in the stouting routines in the code, and 
the most efficient thing seems to be keeping it as a \verb|#define|: for this 
reason, only a check is made to see if the value of $\rho$ you want is in 
the one in code.
  \item{Theory: \verb|FlavourParameters|.}
  Remark: only purely imaginary chemical potential is allowed (because of the 
sign problem)
  \item{Theory: \verb|BackgroundFieldParameters|.}
  An electromagnetic field. Notice that while the magnetic field is real, only 
a purely imaginary electric field is allowed (because of another sign problem).
  \item{Simulation: \verb|MDParameters|.} You can specify the number of steps, 
the number of gauge substeps for each step, the length of the trajectory, and 
the norm (not squared) of the target residue for matrix inversion during 
molecular dynamics evolution. While the other two parameters should be kept as 
low as possible to optimize simulation time, the length of the trajectory 
should be kept equal to $1$ but for bugfixing purposes.

  \item{Simulation: \verb|MontecarloParameters|.} A lot of parameters here: 
\begin{itemize}
 \item \verb|NTraj| is the number of trajectories that have to be performed in 
this run.
\item \verb|ThermNTraj| is the number of trajectories from the beginning of the 
\emph{history} for which the Metropolis test can be skipped. Notice that, if 
the run starts from a configuration which has a nonzero \verb|conf_id| 
(because, for example, it comes from an earlier run) and if \verb|conf_id| is 
larger than \verb|ThermNTraj|, the Metropolis test won't be skipped at all.
\item \verb|StoreConfInterval|: configurations will be stored, with 
\verb|conf_id| in their name, once every this number of trajectories. The name 
is will be the one specified by \verb|StoreConfName| with \verb|conf_id| 
attached to it. 
\item \verb|SaveConfInterval|: the file specified in \verb|SaveConfName| will 
be saved once every this number of trajectories. For safety, set 1, for speed, 
you can increase it.
\end{itemize}
You can also set the \verb|Seed| of the simulation, a parameter 
\verb|EpsGen| defining the randomness in cold gauge conf generation, and the 
verbosity level \verb|VerbosityLv|.
  
  \item{Measures: \verb|GaugeMeasuresSettings|.} Now, only the name of the 
file for the gauge measures is specified. Of course there are, in principle, a 
lot of observables that can be implemented and there are some 
  \item{Measures: \verb|FermionMeasuresSettings|.}
  \item{Device: \verb|DeviceSettings|.} At present, just the choice of the 
device in case of running on a GPU.
  \item{\verb|Geometry|} Here the lattice dimensions are listed and the 
direction mapping too. Unfortunately, the lattice dimensions cannot be set in 
this way; as in the case of \verb|StoutRho| they are read just to check the 
intention of the user and suggest recompilation.  
 \end{itemize}


   \subsubsection{Remarks: verbosity level}
  Don't forget to set the \verb|VerbosityLv| variable to the desired result. 
  The value of it is assigned to the \verb|verbosity_lv| global variable.
  As a rule of thumb, '5' prints all, '1' prints nearly nothing. Note
  that the behaviour of \verb|VerbosityLv| is likely to change over time, no
  policy is yet decided. If you implement anything new, you can use this 
feature to give informative messages.
  
 \subsubsection{Remarks: Optimization of parameters}
 
 There is an interplay between \verb|NmdSteps|, \verb|GaugeSubSteps|,
 \verb|residue_md| and the order of the rational approximations used in the 
 molecular dynamics. The goal of the optimization is to obtain a reasonable 
 value of the acceptance from the Metropolis test while using the lowest value 
 possible. The number of gauge substeps can be set requiring that 
  
  
  \subsubsection{Remarks: seemingly insignificant things that you have to take 
care of}
  A parameter named \verb|ExpMaxEigenvalue| is expected in the 
\verb|MontecarloParameters| group, and represent an estimate
  of the maximum eigenvalue of the Dirac Operator. This will influence
  the choice of the rational approximations you need. Notice that the highest 
eigenvalue of the fermion matrix is calculated during the update and printed 
out if the right verbosity value is set. Notice that the smaller 
\verb|StoutSteps is|, the larger this number is likely to be. 
  
  What you \emph{can't} set with the input file (now) and you have to
  recompile\footnote{ It is not a problem if you use gcc or pgi to compile for 
cpus, but compiling with pgi for gpus can require time, depending on the
   version of the compiler.}:
   \begin{itemize}
    \item The type of gauge action. [triggers some long recompilation]
  \item The stouting strength RHO 
  \item The lattice dimensions in /src/OpenAcc/geometry.h [this will
    practically trigger a full recompilation].
   \end{itemize}
  Of course, changing the input file format requires to recompile the functions 
to read it, in \verb|/src/Include/init.c|.

\subsection{ Rational Approximation files}
  Rational approximations are used to approximate powers (like $1/4$,
  $1/8$) of the Dirac Operator.
  You need $3$ rational approximations files for each quark flavour in the
  theory, one for the first inversion (to map the original
  gaussianly generated pseudofermion to one generated according to the
  right pdf), one used during the molecular dynamics evolution (with a
  lower order, so less precise, for speed), and a third one for the
  calculation of the final action for the metropolis test (more
  precise). At the time of writing, it is common that at least 2 flavour are 
  degenerate in mass, and this allows you to use the same set of rational
  approximations. For example, for a $N_f=2+1$ simulation, you need a total
  of 6 rational approximations.
  NOTICE: the name of the rational approximation file is related to
  its content, and can be generated using the function
  \verb|char* rational_approx_filename()| in
  \verb|src/RationalApprox/rationalapprox.h|.

 \subsubsection{ How to generate and check rational approximations}
  Use the tools in \verb|tools/|. A makefile should be there. 
  \begin{itemize}
  \item '\verb|rgen|' (\verb|rationalapprox_calc.c|) 
   the tool for generating them, it takes the tolerance (plus other
   things) as input and will try to increase the number of poles until
   the required level of acuracy is reached. It takes time to generate
   high order approximations (~minutes). Notice that it needs arbitary
   precision libraries to be compiled.
  \item '\verb|rgenfo|' (\verb|rationalapprox_calc.c|) 
   Same as rgen, but the order of the approximation is fixed.
  \item '\verb|ratnormalizer|' (\verb|normalize_ratapprox.c|) 
   takes a rational approx and
   rescales it so that the upper limit of the validity range is 1.
  \item '\verb|eval_ratapprox|' (\verb|eval_ratapprox.c|)
   Are you sure that your rational approx works? With this tool, you
   can check! \verb|bc -l| is your friend too.
 \end{itemize}
 
\subsection{Gauge configuration files}
  For the format of the gauge configuration files, look in 
  \verb|src/OpenAcc/io.c: print_su3_soa() - read_su3_soa()| or similar.
  The read and/or write of the initial/final gauge configuration file
  is usually done in \verb|/src/OpenAcc/main.c|.

\section{Debug Tools}
Given the intended usage of debug tools, the user/developer should be always 
wary of them, and check that they work as he would expect: debug tools are not 
tested as extensively as the production code. None the less, it seems pretty
reasonable to add some work that has been done on this tools in the released 
code.
  \subsection{ NORANDOM Mode}
  If you need your run to be reproducible for a whole molecular dynamics 
trajectory and want the random number generation not used, use 
\verb|#define NORANDOM|. It may also be useful to shorten the length of the 
trajectory (to improve acceptance).
At present random number generation is used in:
\begin{itemize}
 \item The generation of a new configuration;
 \item The generation of the pseudo fermions for the molecular dynamics 
evolution;
 \item The generation of the momenta for the molecular dynamics evolution.
 \item It is also used to generate the pseudofermions in stochastic fermion 
measurements, however at present this aspect is not touched by 
\verb|#define NORANDOM|.
\end{itemize}
The only files where \verb|#define NORANDOM| has an effect are, at present, 
\verb|/src/OpenAcc/main.c| and \verb|/src/OpenAcc/update_versatile.c|. In order 
to activate NORANDOM mode, you can also add a suitable \verb|-DNORANDOM| in the 
\verb|COMPILER_FLAGS| in the makefile (don't forget to also ``touch'' 
\verb|main.c| and \verb|update_versatile.c| to trigger the compilation of those 
files with \verb|make|).

\subsection{Test for $D_{eo}$ and $D_{oe}$}


\section{Tuning}
To write: setting gauge substep.

\section{Input file reading.}
Input file reading is done in \verb|/src/Include/init.c|. The idea here is to 
read parameters from a file and store them into global variables (or, better, 
into variables of limited number of global structures). The input file should 
be composed by parameter ``macro groups'', with a name that is needed to find 
them, and each of the parameter macro groups consist of a collection of tags 
which are put next to a value (an integer, a floating point number, or a 
string). The function 
\verb|set_global_vars_and_fermions_from_input_file()| does the 
following things:
\begin{enumerate}
 \item Tries do open the specified input file. If it is successful:
  \begin{enumerate}
   \item Loads all the file as an array of lines, and modifies lines removing 
comments (everything beyond a \verb|#| sign, including \verb|#| itself)
   \item Scan the file to find names of macro-groups of parameters, thus 
identifying for each group a type, an initial line and an ending line;
   \item For each of the groups found, it calls the appropriate parser (which 
is actually a wrapper) passing to it the correct \emph{global} data member, 
the start file line and the end file line of the group. Every parser-wrapper 
defines an array of structures of the kind \verb|par_info|:
\begin{verbatim}
 typedef struct par_info_t{
    void* par;
    int type; // 0 = int, 1 = double, 2 = string
    char* name;
}par_info;
\end{verbatim}
Inside every parser-wrapper, this array is passed to a real parser that looks 
for the \verb|name| in the range of lines specified by the parser-wrapper, 
reads a value whose type is speficied in \verb|type|, and puts it into the 
variable pointed at by \verb|par|.
  \end{enumerate}
\item If it is not opened for any reason, it goes into ``help'' mode, and the 
same chain of parser-wrappers and parser is called in help mode writing an 
\verb|input_template| file.
\end{enumerate}
If you want to add another parameter ``macro group'', you have to add the name 
to the \verb|par_macro_groups_names| list, increasing also \verb|NPMGTYPES|.
You also need to create the correct parser-wrapper for it, and modify the 
\verb|set_global_vars_and_fermions_from_input_file()| function to accomodate 
the reading of that parameter ``macro group''.\\
If you want just to add a parameter to an existing group, you just have to 
modify its parser-wrapper and possibly the structure that should hold the value 
of that new parameter.

\section{Configuration file reading}

\subsection{ASCII Format}
To write

\subsection{ILDG Binary format}
To implement. A nice feature to have.


  
  \input{FermionMeasures}
  
\end{document}
  
